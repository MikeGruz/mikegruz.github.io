---
title: "Mapping in R"
date: 2017-03-16
comments: true
layout: post
share: true
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, echo=FALSE}
require(tidyverse)
require(ggmap)
#require(maps)
require(RCurl)
```

Mapping used to be one of those things that always seemed a bit out of reach to all but the GIS folks. Let's be honest: *really good* mapping still very much is. But it like so many things in data manipulation and visualization, it has gotten quite a bit easier to create decent map-based visualizations in *R*.

*R* has had decent mapping capabilities for some time, but (like so many things) these have gotten more accessible with Hadley Wickham's *ggplot* package, which includes the *map_data* set of shapes for political boundaries.

To quickly demonstrate how easy it is to create a map, we can access the shapefile data in *map_data* for state boundaries within the United States and quickly plot it.

```{r state.boundaries}
# load required libraries
require(ggplot2)

# pull state boundaries from map_data
states <- map_data("state")

# view data
head(states)
```

As you can see, dataframes from the *map_data* package include a row-column representation of the longitudes and latitudes of the chosen geography, along with the state (*region*) those boundaries represent.

We'll plot these regions as polygons (*geom_polygon*) using ggplot. Note that we'll use *coord_fixed(1.3)* to keep the aspect ratio consistent and correct.

```{r stateplot}

ggplot(data=states) + geom_polygon(aes(x=long, y=lat, group=group), colour="black", fill='white', size=.25) + coord_fixed(1.3)
```

Easy-peasy. Let's try the same for counties.

```{r countyplot}
# pull in county boundaries data
counties <- map_data("county")

ggplot(data=counties) + geom_polygon(aes(x=long, y=lat, group=group), colour="black", fill='white', size=.25) + coord_fixed(1.3)
```

This is cool, but even cooler would be including some county-level data representing 2016 election returns. Luckily for us, [Tom McGovern](https://github.com/tonmcg) has provided [county-level election results for the 2012-2016 U.S. presidential elections](https://github.com/tonmcg/County_Level_Election_Results_12-16). Let's pull that data into *R* and combine it with the county boundaries.

```{r county.data}
# load the RCurl package to download data from github, as CSV format
elect.data <- read_csv(getURL("https://raw.githubusercontent.com/tonmcg/County_Level_Election_Results_12-16/master/2016_US_County_Level_Presidential_Results.csv"))

# inspect the data
head(elect.data)

  # # remove "county" from name
  # mutate(subregion = tolower(sub(" County", "", county_name)),
  #        subregion = tolower(sub(" parish", "", subregion)),
  #        region = tolower(state.name[match(state_abbr, state.abb)]),
  #        trump.diff = per_gop - per_dem) %>%
  # select(-X1, -state_abbr, -county_name, -combined_fips)
```

Unfortunately for us, the counties map data has (lowercase) full names for the states, whereas the county-level election data has state abbreviations.

We can rectify this by changing the election data's state abbreviations to lowercase full names using the `tolower()` function and the `state.name` and `state.abbr` datasets included in the *R* `datasets` package. County names are also lowercase in the map data, so we'll fix that here as well.

```{r statenames}
elect.data <- elect.data %>%
  # use match to match up state name with state abbreviation, then convert to lower
  # also, to make things easier, name this region, a la county map data
  mutate(region = tolower(state.name[match(state_abbr, state.abb)]),
         subregion = tolower(county_name))
```

First order of business here is to merge the county map data with the election results data. I tend to do a merge immediately and check the result to see if anything doesn't match up, which is very typical when using two (or more) data sources.

For those purposes, I'm going to use `anti_join` from the `dplyr` package, which returns only those rows in *x* (the first dataframe) that do not have matching values in *y* (the second dataframe).

We'll perform the join using state (*region* in both datasets) and county (*subregion* in county map data, *county_name* in election data).

```{r join}
anti_join(counties, elect.data, by=c("region", "subregion")) %>%
  # collapse by region-county to see how many, if any, didn't merge
  mutate(x=1) %>%
  group_by(region, subregion) %>%
  summarise(sum(x))
```

So it turns out that 3,074 of our counties in the mapping data didn't join with anything in the election data. To put that in context, [there are 3,142 counties and county-equivalents in the United States](https://en.wikipedia.org/wiki/List_of_counties_by_U.S._state), meaning that we successfully merged a whopping 2.2% of our data. Sad!

It turns out that most of the county names in our election data have "County" or "Parish" appended to them, while the mapping data omits those designations, which prevents most of the joins of finding a match between the two. Let's go ahead and use *R's* core `sub` function to remove them.

```{r remove.desigs}
elect.data <- elect.data %>%
  # we've aleady made subregion lowercase
  mutate(subregion = sub(" county| parish", "", subregion))

# try the antijoin again, and check our count of leftover counties
anti_join(counties, elect.data, by=c("region","subregion")) %>%
  mutate(x=1) %>%
  group_by(region, subregion) %>%
  summarise(sum(x))
```

Progress! We only have 51 orphaned counties now. 

At this point, it looks like we might have punctuation issues in the county names, as the county data omits punctuation while the election data does not.

```{r puncfind}
elect.data %>%
  filter(grepl("\\.|'", subregion)) %>%
  select(region, subregion)
```

```{r puncfind2}
counties %>%
  filter(grepl("\\.|'", subregion)) %>%
  select(region, subregion)
```

Again, we'll use `sub` to remove that punctuation.

```{r punc}
elect.data <- elect.data %>%
  # use gsub to remove all instances of punctuation, making sure to
  # "escape" the period (\\.), which is a special character
  mutate(subregion = gsub("\\.|'", "", subregion))

# check the antijoin
anti_join(counties, elect.data, by=c("region","subregion")) %>%
  mutate(x = 1) %>%
  group_by(region, subregion) %>%
  summarise(sum(x))
```

Almost there. On further investigation, it looks like county names like "DeKalb" in Indiana have a space where there shouldn't be one in the counties ("De Kalb") data. Let's change the election data to include that space (while I go and make a pull request in the ggplot library). We will match all of the strings manually using an `ifelse` statement, and then arbitrarily enter a space after the second character using `sub`.

```{r change.spaces}
# we'll match on this grep string
county.matches <- "desoto|dekalb|dupage|lasalle|laporte|lamoure|dewitt"

elect.data <- elect.data %>% 
  mutate(subregion = ifelse(grepl(county.matches, subregion),
                 # if county matches, place space at third character
                 sub("^([a-z]{2})([a-z]+)", "\\1 \\2", subregion),
                 # if no match, keep the same
                 subregion)
  )
```

Let's try the join again.

```{r}
anti_join(counties, elect.data, by=c("region","subregion")) %>%
  mutate(x=1) %>%
  group_by(region, subregion) %>%
  summarise(sum(x))
```

Close enough! (Change this later). Let's go ahead and join the two datasets.

```{r}
counties.elect <- full_join(counties, elect.data, by=c("region","subregion"))
```

We're about ready to map out the win percentage for Trump in 2016; we just need to create a variable subtracting Clinton's percentage of the vote from Trump's percentage.

```{r}
counties.elect <- counties.elect %>%
  mutate(trump.perc = (per_gop - per_dem)*100)
```

And now we'll map it, using the same `ggplot` code as before while adding a `fill=` statement to fill in a gradient based on the percent differential between the two candidates.

```{r countymap}
# we're going to use the "scales" package to mute the color

ggplot(data=counties.elect) + 
  # use "fill=trump.perc" to create a gradient based on two-party differential
  geom_polygon(aes(x=long, y=lat, group=group, fill=trump.perc)) +
  # use scale_fill_gradient to do a red-blue gradient
  scale_fill_gradient2(low = "blue", mid="grey", high = "red", name="Trump Win %") +
  coord_fixed(1.3) + theme_minimal() +
  theme(axis.title = element_blank(), 
        axis.text =element_blank(),
        panel.grid = element_blank())
        
```


```{r usdamap}
# get usda funding data
# usda <- getURL("http://download.usaspending.gov/datadownlods/Assistance/a3bc5309d872/Data_Feed.csv") %>%
#   read_csv()
# 
# usda.funds <- usda %>%
#   mutate(region = tolower(state.name[match(recipient_state_code, state.abb)]),
#          subregion = tolower(recipient_county_name)) %>%
#   group_by(region, subregion) %>%
#   summarise(funding = sum(fed_funding_amount, na.rm=TRUE))
# 
# counties.usda <- full_join(counties, usda.funds, by=c("region","subregion"))
# 
# ggplot(data=counties.usda) + geom_polygon(aes(x=long, y=lat, group=group, fill=funding)) +
#   coord_fixed(1.3) + theme_nothing()
```






